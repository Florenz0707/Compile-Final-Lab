# C--编译器源码结构和功能详细说明

## 目录
1. [词法分析器](#1-词法分析器)
2. [语法分析器](#2-语法分析器)
3. [语法树存储与遍历及IR生成](#3-语法树存储与遍历及ir生成)

---

## 1. 词法分析器

### 1.1 算法描述

本项目实现了两种词法分析器：

#### 方法一：基于DFA状态机的词法分析器 (`Lexer`)

**算法流程：**
1. **初始化阶段**：
   - 初始化关键字表（int, void, return, const, float, if, else）
   - 设置当前位置指针 `pos = 0`，行号 `line = 1`，列号 `column = 1`

2. **主分析循环** (`tokenize()` 函数)：
   ```
   WHILE pos < source.length():
       跳过空白字符 (空格、制表符、换行符)
       跳过注释 (// 行注释 或 /* */ 块注释)

       IF 当前位置字符是字母或下划线:
           调用 scanIdentifier() 扫描标识符或关键字
       ELSE IF 当前位置字符是数字:
           调用 scanNumber() 扫描整数或浮点数
       ELSE IF 当前位置字符是界符 ( ( ) { } ; , ):
           调用 scanSeparator() 扫描界符
       ELSE IF 当前位置字符是运算符 ( + - * / % = < > ! & | ):
           调用 scanOperator() 扫描运算符
       ELSE:
           创建ERROR token

       将扫描到的token添加到tokens列表
   END WHILE

   添加EOF token
   ```

3. **DFA状态转换**：
   - `START`: 初始状态
   - `IN_ID`: 标识符状态（字母/下划线开头，后跟字母/数字/下划线）
   - `IN_NUM`: 整数状态（数字序列）
   - `IN_FLOAT`: 浮点数状态（数字.数字）
   - `IN_ASSIGN`: =状态（可能是=或==）
   - `IN_LT`: <状态（可能是<或<=）
   - `IN_GT`: >状态（可能是>或>=）
   - `IN_NOT`: !状态（需要!=）
   - `IN_AND`: &状态（需要&&）
   - `IN_OR`: |状态（需要||）
   - `IN_COMMENT_LINE`: 行注释状态
   - `IN_COMMENT_BLOCK`: 块注释状态

#### 方法二：基于NFA→DFA转换的词法分析器 (`SLRLexer`)

**算法流程：**
1. **构建NFA** (`buildDFA()` 函数)：
   - 为关键字、标识符、整数、浮点数、运算符、界符分别构建NFA
   - 使用epsilon转换合并所有NFA为一个组合NFA
   - 通过子集构造法（Subset Construction）将NFA转换为DFA
   - 使用DFA最小化算法优化DFA

2. **最长匹配算法** (`analyze()` 函数)：
   ```
   初始化: currentState = dfa.start, startPos = pos

   WHILE pos < source.length():
       跳过空白字符和注释

       currentState = dfa.start
       startPos = pos
       lastAcceptState = nullptr
       lastAcceptPos = -1
       currentPos = pos

       // 最长匹配
       WHILE currentPos < source.length():
            char c = sourceCode[currentPos]
            IF currentState有c的转换:
                currentState = currentState.transitions[c]
                currentPos++
                IF currentState是接受状态:
                    lastAcceptState = currentState
                    lastAcceptPos = currentPos
            ELSE:
                BREAK
       END WHILE

       IF lastAcceptState != nullptr AND lastAcceptPos > startPos:
           创建token: Token(lastAcceptState->acceptType,
                           sourceCode.substr(startPos, lastAcceptPos - startPos))
            pos = lastAcceptPos
       ELSE:
           创建ERROR token
            pos++
   END WHILE

   添加EOF token
   ```

### 1.2 输出格式说明

**Token输出格式：** `[单词符号] TAB <[类型],[属性]>`

**类型分类：**
- **KW (关键字)**: int(1), void(2), return(3), const(4), float(6), if(7), else(8)
- **OP (运算符)**: +(30), -(31), *(32), /(33), %(34), =(35), >(36), <(37), ==(38), <=(39), >=(40), !=(41), &&(42), ||(43), !(44)
- **SE (界符)**: ((50), )(51), {(52), }(53), ;(54), ,(55)
- **IDN (标识符)**: `<IDN,标识符名称>`
- **INT (整数)**: `<INT,整数值>`
- **FLOAT (浮点数)**: `<FLOAT,浮点数值>`
- **EOF (文件结束)**: `$`

**示例输出：**
```
int	<KW,1>
main	<IDN,main>
(	<SE,50>
)	<SE,51>
{	<SE,52>
return	<KW,3>
10	<INT,10>
;	<SE,54>
}	<SE,53>
```

### 1.3 源程序编译步骤

**使用词法分析器的编译步骤：**

1. **加载源文件**：
   ```cpp
   Lexer lexer;
   lexer.loadFromFile("source.sy");
   ```

2. **执行词法分析**：
   ```cpp
   lexer.tokenize();
   ```

3. **获取Token序列**：
   ```cpp
   const auto& tokens = lexer.getTokens();
   ```

4. **输出结果**：
   ```cpp
   lexer.printTokens();  // 打印到标准输出
   // 或
   std::string tokenStr = lexer.getTokensString();  // 获取字符串
   ```

**命令行使用：**
```bash
./compiler -l source.sy    # 仅词法分析
```

---

## 2. 语法分析器

### 2.1 算法描述

本项目实现了两种语法分析器：

#### 方法一：递归下降语法分析器 (`Parser`)

**算法特点：**
- 为每个非终结符编写一个递归函数
- 通过向前看（lookahead）解决选择冲突
- 自顶向下构建AST

**主要分析函数：**
- `parseCompUnit()`: 解析编译单元
- `parseConstDecl()`: 解析常量声明
- `parseVarDecl()`: 解析变量声明
- `parseFuncDef()`: 解析函数定义
- `parseStmt()`: 解析语句
- `parseExp()`: 解析表达式（通过parseAddExp）
- `parseCond()`: 解析条件表达式

**算法流程示例（parseAddExp）：**
```
parseAddExp():
    left = parseMulExp()

    WHILE 当前token是 + 或 -:
        保存运算符op
        前进token
        right = parseMulExp()
        创建新的AddExpNode，left作为左子树，right作为右子树
        left = 新节点
    END WHILE

    RETURN left
```

#### 方法二：SLR语法分析器 (`SLRParser`)

**算法流程：**

1. **初始化文法** (`initGrammar()`):
   - 定义81个产生式规则
   - 识别终结符和非终结符集合

2. **计算FIRST集** (`computeFirst()`):
   ```
   FOR 每个终结符t:
       FIRST(t) = {t}

   WHILE FIRST集发生变化:
       FOR 每个产生式 A -> α:
           IF α = ε:
               FIRST(A) += {ε}
           ELSE:
               FOR 每个符号X in α:
                   FIRST(A) += FIRST(X) - {ε}
                   IF ε NOT IN FIRST(X):
                       BREAK
                   IF 到达α的末尾:
                       FIRST(A) += {ε}
   END WHILE
   ```

3. **计算FOLLOW集** (`computeFollow()`):
   ```
   FOLLOW(开始符号) = {$}

   WHILE FOLLOW集发生变化:
       FOR 每个产生式 A -> αBβ:
           IF β存在:
               FOLLOW(B) += FIRST(β) - {ε}
               IF ε IN FIRST(β):
                   FOLLOW(B) += FOLLOW(A)
           ELSE:
               FOLLOW(B) += FOLLOW(A)
   END WHILE
   ```

4. **构建LR(0)项目集族** (`buildCollection()`):
   ```
   I0 = closure({S' -> ·Program})
   canonicalCollection = {I0}

   WHILE 有新的项目集产生:
       FOR 每个项目集I:
           FOR 每个符号X (终结符或非终结符):
               J = goto(I, X)
               IF J非空 AND J不在canonicalCollection中:
                   将J添加到canonicalCollection
                   记录转换: (I, X) -> J
   END WHILE
   ```

5. **构建SLR分析表** (`buildTable()`):
   ```
   FOR 每个项目集Ii:
       FOR 每个项目 [A -> α·aβ] in Ii:
           J = goto(Ii, a)
           action[i, a] = shift j

       FOR 每个项目 [A -> α·] in Ii:
           IF A != S':
               FOR 每个a IN FOLLOW(A):
                   action[i, a] = reduce A -> α
           ELSE:
               action[i, $] = accept

       FOR 每个非终结符A:
           IF goto(Ii, A) = Ij:
               goto[i, A] = j
   ```

6. **SLR分析算法** (`parse()`):
   ```
   初始化: stateStack = [0], valueStack = []
   ip = 0  // 输入指针

   WHILE true:
       s = stateStack.top()
       a = tokens[ip]  // 当前输入符号

       IF action[s, a] = shift t:
           stateStack.push(t)
           valueStack.push(语义值)
           ip++

       ELSE IF action[s, a] = reduce A -> β:
           从栈中弹出|β|个状态和语义值
           t = stateStack.top()
           stateStack.push(goto[t, A])
           valueStack.push(reduce(产生式ID, 语义值列表))

       ELSE IF action[s, a] = accept:
           RETURN success

       ELSE:
           RETURN error
   END WHILE
   ```

### 2.2 SLR分析表结构

**分析表包含两部分：**

1. **ACTION表**：`actionTable[state, terminal] -> Action`
   - `SHIFT n`: 移进，跳转到状态n
   - `REDUCE m`: 归约，使用产生式m
   - `ACC`: 接受
   - `ERR`: 错误

2. **GOTO表**：`gotoTable[state, nonTerminal] -> state`
   - 记录状态转换

**冲突解决：**
- 移进-归约冲突：优先移进（shift-reduce conflict resolution）

**示例分析表片段：**
```
State 0:
  action[0, "int"] = shift 5
  action[0, "const"] = shift 6
  goto[0, "Program"] = 1
  goto[0, "compUnit"] = 2

State 5:
  action[5, "Ident"] = shift 10
  goto[5, "bType"] = 7

State 10:
  action[10, "="] = shift 15
  action[10, ";"] = reduce 19  // varDef -> Ident
  ...
```

### 2.3 输出格式说明

**递归下降分析器输出格式：**
```
步骤号	TAB	Token值	TAB	动作
1	int	move
2	main	move
3	(	move
4	)	move
5	{	move
6	return	move
7	10	move
8	;	move
9	Stmt	reduction
10	Block	reduction
11	FuncDef	reduction
12	compUnit	reduction
13	$#$	accept
```

**动作类型：**
- `move`: 移进（匹配终结符）
- `reduction`: 归约（应用产生式）
- `accept`: 接受
- `error`: 错误

### 2.4 源程序编译步骤

**使用语法分析器的编译步骤：**

1. **词法分析**：
   ```cpp
   SLRLexer lexer;
   auto tokens = lexer.analyze(sourceCode);
   ```

2. **语法分析**：
   ```cpp
   SLRParser parser;
   bool success = parser.parse(tokens);
   ```

3. **获取AST**：
   ```cpp
   auto ast = parser.getAST();
   ```

**命令行使用：**
```bash
./compiler -p source.sy    # 词法+语法分析
```

---

## 3. 语法树存储与遍历及IR生成

### 3.1 语法树存储结构

**AST节点层次结构：**

```
CompUnitNode (根节点)
├── decls: vector<DeclNode*>          // 全局声明列表
│   ├── ConstDeclNode
│   │   ├── bType: BType
│   │   └── constDefs: vector<ConstDefNode*>
│   │       └── ConstDefNode
│   │           ├── ident: string
│   │           └── initVal: ExpNode*
│   └── VarDeclNode
│       ├── bType: BType
│       └── varDefs: vector<VarDefNode*>
│           └── VarDefNode
│               ├── ident: string
│               └── initVal: ExpNode* (可选)
│
└── funcDefs: vector<FuncDefNode*>     // 函数定义列表
    └── FuncDefNode
        ├── returnType: BType
        ├── ident: string
        ├── params: vector<FuncFParamNode*>
        └── block: BlockNode*
            └── items: vector<BlockItemNode*>
                ├── decl: DeclNode* (可选)
                └── stmt: StmtNode* (可选)
                    ├── ASSIGN: lVal + exp
                    ├── EXP: exp (可选)
                    ├── BLOCK: block
                    ├── IF: cond + thenStmt + elseStmt (可选)
                    └── RETURN: exp (可选)
```

**表达式节点层次：**
```
ExpNode (基类)
├── AddExpNode
│   ├── left: AddExpNode* (可选)
│   ├── op: BinaryOp (ADD/SUB)
│   └── right: MulExpNode*
│
├── MulExpNode
│   ├── left: MulExpNode* (可选)
│   ├── op: BinaryOp (MUL/DIV/MOD)
│   └── right: UnaryExpNode*
│
├── UnaryExpNode
│   ├── PRIMARY: primaryExp
│   ├── FUNC_CALL: funcName + args
│   └── UNARY_OP: unaryOp + unaryExp
│
├── PrimaryExpNode
│   ├── PAREN_EXP: exp
│   ├── LVAL: lVal
│   └── NUMBER: number
│
├── LValNode
│   └── ident: string
│
└── NumberNode
    ├── isFloat: bool
    ├── intVal: int
    └── floatVal: float
```

**存储方式：**
- 使用 `std::shared_ptr` 智能指针管理节点生命周期
- 树形结构通过指针链接
- 列表使用 `std::vector<std::shared_ptr<Node>>`

### 3.2 语法树遍历算法伪代码

**访问者模式遍历AST：**

```
算法: visitCompUnit(node)
输入: CompUnitNode* node
输出: 无

BEGIN
    // 先处理全局声明
    FOR EACH decl IN node->decls:
        visitDecl(decl)
    END FOR

    // 再处理函数定义
    FOR EACH funcDef IN node->funcDefs:
        visitFuncDef(funcDef)
    END FOR
END

算法: visitDecl(node)
输入: DeclNode* node
输出: 无

BEGIN
    IF node是ConstDeclNode:
        visitConstDecl(node)
    ELSE IF node是VarDeclNode:
        visitVarDecl(node)
    END IF
END

算法: visitFuncDef(node)
输入: FuncDefNode* node
输出: 无

BEGIN
    // 创建函数
    retType = bTypeToLLVMType(node->returnType)
    paramTypes = []
    FOR EACH param IN node->params:
        paramTypes.append(bTypeToLLVMType(param->bType))
    END FOR

    func = Function::create(FunctionType::get(retType, paramTypes),
                              node->ident, module)

    // 创建入口基本块
    entryBB = BasicBlock::create(module, node->ident + "_ENTRY", func)
    builder->set_insert_point(entryBB)

    // 进入函数作用域
    symbolTable.enterScope()

    // 处理参数
    FOR EACH param IN node->params:
        alloca = createLocalVariable(param->ident, paramType)
        builder->create_store(arg, alloca)
        symbolTable.insert(param->ident, alloca, paramType, false)
    END FOR

    // 处理函数体
    visitBlock(node->block)

    // 如果基本块没有终结指令，添加默认返回
    IF currentBB没有终结指令:
        IF retType是void:
            builder->create_void_ret()
        ELSE:
            builder->create_ret(ConstantInt::get(0, module))
        END IF
    END IF

    // 退出函数作用域
    symbolTable.exitScope()
END

算法: visitStmt(node)
输入: StmtNode* node
输出: 无

BEGIN
    SWITCH node->stmtType:
        CASE ASSIGN:
            addr = visitLVal(node->lVal, false)  // 获取地址
            val = visitExp(node->exp)             // 计算值
            builder->create_store(val, addr)      // 存储
        CASE EXP:
            IF node->exp存在:
                visitExp(node->exp)               // 计算表达式（丢弃结果）
            END IF
        CASE BLOCK:
            visitBlock(node->block)
        CASE IF:
            visitIfStmt(node)
        CASE RETURN:
            visitReturnStmt(node)
    END SWITCH
END

算法: visitExp(node)
输入: ExpNode* node
输出: Value* (IR值)

BEGIN
    IF node是AddExpNode:
        RETURN visitAddExp(node)
    ELSE IF node是MulExpNode:
        RETURN visitMulExp(node)
    ELSE IF node是UnaryExpNode:
        RETURN visitUnaryExp(node)
    ELSE IF node是PrimaryExpNode:
        RETURN visitPrimaryExp(node)
    ELSE IF node是LValNode:
        RETURN visitLVal(node, true)  // 加载值
    ELSE IF node是NumberNode:
        RETURN visitNumber(node)
    END IF
END

算法: visitAddExp(node)
输入: AddExpNode* node
输出: Value*

BEGIN
    IF node->left == nullptr:
        // 只有右操作数
        RETURN visitMulExp(node->right)
    END IF

    // 递归计算左操作数
    left = visitAddExp(node->left)
    right = visitMulExp(node->right)

    // 类型提升
    IF left是float类型 OR right是float类型:
        IF left是int类型:
            left = builder->create_sitofp(left, floatType)
        END IF
        IF right是int类型:
            right = builder->create_sitofp(right, floatType)
        END IF
    END IF

    // 生成IR指令
    IF node->op == ADD:
        IF 是float类型:
            RETURN builder->create_fadd(left, right)
        ELSE:
            RETURN builder->create_iadd(left, right)
        END IF
    ELSE IF node->op == SUB:
        IF 是float类型:
            RETURN builder->create_fsub(left, right)
        ELSE:
            RETURN builder->create_isub(left, right)
        END IF
    END IF
END

算法: visitLVal(node, load)
输入: LValNode* node, bool load
输出: Value*

BEGIN
    info = symbolTable.lookup(node->ident)
    IF info == nullptr:
        报错: 未定义的变量
        RETURN nullptr
    END IF

    addr = info->value

    IF load == true:
        IF addr是Argument类型:
            RETURN addr  // 参数直接返回值
        END IF
        // 加载值
        loadType = addr->get_type()->get_pointer_element_type()
        RETURN builder->create_load(loadType, addr)
    ELSE:
        RETURN addr  // 返回地址
    END IF
END

算法: visitIfStmt(node)
输入: StmtNode* node
输出: 无

BEGIN
    // 创建基本块
    thenBB = BasicBlock::create(module, "", currentFunction)
    IF node->elseStmt存在:
        elseBB = BasicBlock::create(module, "", currentFunction)
    ELSE:
        elseBB = nullptr
    END IF
    mergeBB = BasicBlock::create(module, "", currentFunction)

    // 计算条件
    condVal = visitCond(node->cond)
    condVal = ensureInt1(condVal)  // 转换为i1类型

    // 条件跳转
    IF elseBB存在:
        builder->create_cond_br(condVal, thenBB, elseBB)
    ELSE:
        builder->create_cond_br(condVal, thenBB, mergeBB)
    END IF

    // 生成then分支
    currentBB = thenBB
    builder->set_insert_point(thenBB)
    visitStmt(node->thenStmt)
    IF currentBB没有终结指令:
        builder->create_br(mergeBB)
    END IF

    // 生成else分支
    IF elseBB存在 AND node->elseStmt存在:
        currentBB = elseBB
        builder->set_insert_point(elseBB)
        visitStmt(node->elseStmt)
        IF currentBB没有终结指令:
            builder->create_br(mergeBB)
        END IF
    END IF

    // 设置当前基本块为merge
    currentBB = mergeBB
    builder->set_insert_point(mergeBB)
END
```

### 3.3 调用中端的过程的算法设计思想

**IR生成器的设计思想：**

1. **访问者模式**：
   - 为每种AST节点类型定义访问函数
   - 通过动态分发（dynamic_cast）选择正确的访问函数
   - 递归遍历AST树

2. **符号表管理**：
   ```
   算法: 符号表作用域管理

   enterScope():
       创建新的Scope并压入作用域栈

   exitScope():
       弹出当前作用域（保留全局作用域）

   lookup(name):
       从内层作用域向外查找符号

   insert(name, value, type, isConst):
       在当前作用域插入符号
   ```

3. **基本块管理**：
   - 每个函数有一个入口基本块
   - 控制流语句（if、while等）创建新的基本块
   - 使用Phi节点处理控制流合并

4. **类型系统**：
   ```
   BType -> LLVM Type映射:
       INT -> i32
       FLOAT -> float
       VOID -> void
   ```

5. **常量折叠**：
   ```
   算法: evalConstInt(node)
   输入: ExpNode* node
   输出: int

   BEGIN
       IF node是NumberNode:
           RETURN node->intVal
       ELSE IF node是AddExpNode:
           left = evalConstInt(node->left)
           right = evalConstInt(node->right)
           RETURN left + right
       ELSE IF node是MulExpNode:
           left = evalConstInt(node->left)
           right = evalConstInt(node->right)
           RETURN left * right
       ...
   END
   ```

6. **短路求值**（逻辑与/或）：
   ```
   算法: visitLAndExp(node)
   输入: LAndExpNode* node
   输出: Value* (i1类型)

   BEGIN
       IF node->left == nullptr:
           RETURN visitEqExp(node->right)
       END IF

       // 创建基本块
       rhsBB = BasicBlock::create(...)
       mergeBB = BasicBlock::create(...)

       // 计算左操作数
       leftVal = visitLAndExp(node->left)
       leftVal = ensureInt1(leftVal)
       leftBB = currentBB

       // 短路：左边为真则计算右边，否则跳到merge
       builder->create_cond_br(leftVal, rhsBB, mergeBB)

       // 计算右操作数
       currentBB = rhsBB
       builder->set_insert_point(rhsBB)
       rightVal = visitEqExp(node->right)
       rightVal = ensureInt1(rightVal)
       builder->create_br(mergeBB)
       rightEndBB = currentBB

       // merge基本块
       currentBB = mergeBB
       builder->set_insert_point(mergeBB)

       // 创建phi节点
       phi = PhiInst::create_phi(int1Type, mergeBB)
       phi->add_phi_pair_operand(ConstantInt::get(false), leftBB)
       phi->add_phi_pair_operand(rightVal, rightEndBB)

       RETURN phi
   END
   ```

7. **IR生成流程**：
   ```
   算法: generate(ast)
   输入: CompUnitNode* ast
   输出: 无

   BEGIN
       // 1. 遍历AST，生成IR
       visitCompUnit(ast)

       // 2. 设置打印名称
       module->set_print_name()
   END

   算法: print()
   输出: string (LLVM IR文本)

   BEGIN
       RETURN module->print()
   END
   ```

**IR生成示例：**

输入AST：
```
CompUnit
├── VarDecl (int a = 10)
└── FuncDef (int main() { return 0; })
```

生成的LLVM IR：
```llvm
@a = global i32 10

define i32 @main() {
entry:
    ret i32 0
}
```

### 3.4 源程序编译步骤（完整流程）

**完整编译流程：**

1. **词法分析**：
   ```cpp
   SLRLexer lexer;
   auto tokens = lexer.analyze(sourceCode);
   ```

2. **语法分析**：
   ```cpp
   SLRParser parser;
   bool success = parser.parse(tokens);
   auto ast = parser.getAST();
   ```

3. **IR生成**：
   ```cpp
   IRGenerator generator("source.sy");
   generator.generate(ast);
   std::string ir = generator.print();
   ```

**命令行使用：**
```bash
./compiler -i source.sy    # 完整编译（生成LLVM IR）
```

---

## 总结

本编译器实现了完整的编译流程：
1. **词法分析**：将源代码转换为Token序列
2. **语法分析**：将Token序列解析为AST
3. **IR生成**：遍历AST生成LLVM IR中间代码

关键特性：
- 支持两种词法分析器（DFA状态机、NFA→DFA）
- 支持两种语法分析器（递归下降、SLR）
- 完整的AST节点体系
- 符号表作用域管理
- 类型系统和类型提升
- 常量折叠优化
- 短路求值
- 控制流图生成
